# 安全即时通讯系统后端开发总结报告书

## 1 引言:**安全通信落地**与**协作打磨**
        随着互联网技术的飞速发展，即时通讯系统已深度融入人们的日常生活与工作场景，成为信息传递与社交互动的核心工
    具。从个人社交聊天到企业协同办公，即时通讯系统的高效性、便捷性和实时性极大地改变了人们的沟通模式。在此背景下，
    基于 Python 语言开发一套融合 P2P 与 C/S 架构优势的即时通讯系统，不仅有助于深入理解网络通信、数据存储等核心
    技术，更是对理论知识与实践能力结合的有效检验。​

        本项目旨在开发一套功能完备、安全可靠的即时通讯系统。系统采用 P2P 与 C/S 混合架构，结合两种架构的优势:P2P 
    架构支持用户间直接通信，减少服务器负载，提升数据传输效率；C/S 架构则保障用户离线时消息的可靠缓存与转发，确保
    信息不丢失。系统涵盖用户注册登录、通讯录管理、实时消息传输等基础功能，并进一步拓展至端到端透明安全加解密、图
    片信息隐藏提取、在线状态管理以及公私钥维护等高级功能。其中，端到端加密技术确保用户信息在传输与存储过程中的安
    全性，信息隐藏功能则为数据传输提供了额外的隐私保护，在线状态管理则提升了用户交互体验。​

       作为小学期的实践成果，本项目不仅是对 Python 编程能力的全面锻炼，更是对网络通信、数据库管理、密码学等多学科
    知识的综合运用。通过本系统的开发，不仅实现了即时通讯系统的基本功能需求，更在安全性与隐私保护方面进行了有益探索，
    通过 RSA + AES 混合加密、JWT 认证等技术，实现端到端安全传输，掌握密码学算法在实际场景的应用;模拟团队开发流程，
    通过模块拆分（用户模块、通信模块等）、Git 版本控制，提升协作效率与项目管理能力。为后续相关系统的研究与开发提供参
    考与借鉴。

## 2 相关理论及基础技术与开发平台
### 2.1 即时通讯应用工作原理分析
        C/S 架构原理：客户端负责用户界面展示、输入输出交互，服务器作为中枢管理用户认证、消息存储与转发。用户登录时，客户
    端向服务器发送账号密码，服务器通过数据库验证后建立连接；用户离线时，消息暂存服务器，待用户上线后推送，确保消息不丢失。​
        P2P 架构原理：在用户在线且网络条件允许时，双方直接建立连接传输消息，无需服务器中转，降低服务器负载并提升传输效率。通
    过NAT穿越技术，解决不同网络环境下节点间的通信问题，实现点对点直连。​
       混合架构协同：系统根据用户在线状态和网络状况动态切换架构，在线用户优先使用 P2P 传输，离线或直连失败时启用 C/S 模式，
    由服务器缓存并转发消息，兼顾性能与可靠性。

### 2.2 所用技术
 **技术实践深化**：完整落地用户交互，用户认证、数据库交互、安全通信等功能，强化开发工程化思维，运用技术栈如下：
      *   **后端:** Python, **FastAPI**, Uvicorn, `python-jose` (用于JWT认证)
      *   **前端:** **uniapp** (Vue 3), **Element Plus** (仅用于H5端), Pinia
      *   **实时通信:** **WebSockets** (用于信令), **WebRTC** (用于P2P数据)
      *   **数据库:** SQLite

## 3 系统体系结构的设计

### 3.1 需求描述

#### 1. 用户核心功能  
- **注册登录**：支持用户名、邮箱、密码提交，通过 JWT 生成身份令牌，实现状态保持。  
- **通讯录管理**：提供好友添加、删除、列表查询接口，关联用户 ID 维护好友关系。  

#### 2. 安全通讯功能  
- **消息加密**：采用 RSA 协商 AES 密钥，对称加密消息正文，保障端到端安全。  
- **信息隐藏**：预留 LSB 算法扩展，支持图片载体的信息嵌入与提取（待实现）。  


#### 3. 服务器功能  
- **用户管理**：校验注册唯一性，维护在线状态（IP、端口），支持公钥分发。  
- **消息中转**：离线消息暂存、在线消息 P2P 直传（待完善 NAT 穿透）。
- 
#### 4.性能与约束  
- **实时性**：在线消息延迟≤500ms（当前测试环境达标），离线消息转发成功率≥99%（待压测验证）。  
- **安全约束**：密钥协商防中间人攻击，消息加密符合 AES-256 标准，密码存储采用 BCrypt 哈希。  
- **技术栈**：后端 Python + FastAPI + SQLAlchemy（SQLite 数据库），前端预留 Qt 集成接口（待开发）。 

### 3.2 系统架构设计
### 3.3 系统的总体功能设计
#### 3.3.1 总体功能设计
#### 3.3.2 注册模块设计
#### 3.3.3 登录模块设计
#### 3.3.4 用户间交互模块设计
### 3.4 数据库设计
#### 3.4.1 数据库物理模型
#### 3.4.2 数据字典

## 4 系统实现
### 4.1 网络通讯编码实现
#### 4.1.1 聊天客户端部分代码
#### 4.1.2 服务器端监听与转发消息代码
#### 4.1.3 服务端单线程上线处理代码
### 4.2 系统运行的效果图
#### 4.2.1 登录界面
#### 4.2.2 主界面
#### 4.2.3 群聊天界面
#### 4.2.4 好友聊天界面
#### 4.2.5 好友查找界面
### 4.3 注册模块的实现
#### 4.3.1 数据库连接
#### 4.3.2 字符编码过滤器的核心代码
### 4.4 注册模块运行效果图
#### 4.4.1 主页面
#### 4.4.2 注册页面

## 5 系统测试与运行




```python
'''
## 一、课程设计目的  
本次课程设计聚焦安全即时通讯系统后端开发，目标如下：  
1. **技术实践深化**：基于 Python + FastAPI 技术栈，完整落地用户认证、数据库交互、安全通信等功能，强化后端开发工程化思维。  
2. **安全通信落地**：通过 RSA + AES 混合加密、JWT 认证等技术，实现端到端安全传输，掌握密码学算法在实际场景的应用。  
3. **团队协作打磨**：模拟团队开发流程，通过模块拆分（用户模块、通信模块等）、Git 版本控制，提升协作效率与项目管理能力。  


## 二、需求分析  
### （一）系统功能需求  
#### 1. 用户核心功能  
- **注册登录**：支持用户名、邮箱、密码提交，通过 JWT 生成身份令牌，实现状态保持。  
- **通讯录管理**：提供好友添加、删除、列表查询接口，关联用户 ID 维护好友关系。  

#### 2. 安全通讯功能  
- **消息加密**：采用 RSA 协商 AES 密钥，对称加密消息正文，保障端到端安全。  
- **信息隐藏**：预留 LSB 算法扩展，支持图片载体的信息嵌入与提取（待实现）。  

#### 3. 服务器功能  
- **用户管理**：校验注册唯一性，维护在线状态（IP、端口），支持公钥分发。  
- **消息中转**：离线消息暂存、在线消息 P2P 直传（待完善 NAT 穿透）。  


### （二）性能与约束  
- **实时性**：在线消息延迟≤500ms（当前测试环境达标），离线消息转发成功率≥99%（待压测验证）。  
- **安全约束**：密钥协商防中间人攻击，消息加密符合 AES-256 标准，密码存储采用 BCrypt 哈希。  
- **技术栈**：后端 Python + FastAPI + SQLAlchemy（SQLite 数据库），前端预留 Qt 集成接口（待开发）。  


## 三、详细设计  
### （一）总体框架  
#### 1. 混合通信架构  
- **C/S 模式**：承担用户认证、离线消息存储、在线状态管理（如 `/users/` 注册接口、`/token` 登录接口）。  
- **P2P 模式**：在线用户通过 NAT 穿透直连（待实现），降低服务器转发压力，提升通信效率。  

#### 2. 数据库设计（核心表结构）  
```python
# 模型类定义（SQLAlchemy ORM）
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    password_hash = Column(String)  # BCrypt 哈希存储
    public_key = Column(String)     # RSA 公钥
    contacts = relationship("Contact", back_populates="user")  # 好友关系

class Contact(Base):
    __tablename__ = "contacts"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    friend_id = Column(Integer, ForeignKey("users.id"))
    user = relationship("User", foreign_keys=[user_id], back_populates="contacts")


### (二)算法分析与实现
#### 1. 加密流程设计（RSA + AES 混合加密）
'''